"use strict";(self.webpackChunk_openfn_docs=self.webpackChunk_openfn_docs||[]).push([[1448],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return d}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),d=o,f=m["".concat(p,".").concat(d)]||m[d]||u[d]||a;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},58212:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return s},default:function(){return f},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return m}});var r=n(83117),o=n(80102),a=(n(67294),n(3905)),i=n(22004),l=["components"],p={title:"Portability"},s=void 0,c={unversionedId:"portability",id:"portability",title:"Portability",description:"Intent",source:"@site/docs/portability.md",sourceDirName:".",slug:"/portability",permalink:"/documentation/portability",draft:!1,editUrl:"https://github.com/openfn/docs/edit/main/docs/portability.md",tags:[],version:"current",frontMatter:{title:"Portability"},sidebar:"docs",previous:{title:"Planning for Deployment",permalink:"/documentation/deploy/options"},next:{title:"Platform",permalink:"/documentation/deploy/platform"}},u={},m=[{value:"Intent",id:"intent",level:2},{value:"Proposal v2 <code>@latest</code>",id:"proposal-v2-latest",level:2},{value:"Other Versions",id:"other-versions",level:2}],d={toc:m};function f(e){var t=e.components,n=(0,o.Z)(e,l);return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"intent"},"Intent"),(0,a.kt)("p",null,"Beyond facilitating portability/transferability between OpenFn's\n",(0,a.kt)("a",{parentName:"p",href:"deploy/platform"},"platform")," and ",(0,a.kt)("a",{parentName:"p",href:"/documentation/microservice/home"},"microservice"),"\ndeployment pathways, the portability proposal (needs a better name... and...)\nseeks to establish a simple, globally-applicable way of ",(0,a.kt)("strong",{parentName:"p"},"specifying workflow\nautomation")," that might be applied across workflow-engines/integration platforms\nacross the sector. Nothing about the spec ",(0,a.kt)("em",{parentName:"p"},"must")," be specific to OpenFn or any\none of our individual products. We envision a future in which software built on\n",(0,a.kt)("a",{parentName:"p",href:"deploy/diy"},"core"),", ",(0,a.kt)("a",{parentName:"p",href:"deploy/diy"},"engine"),", and entirely new and different\nintegration/workflow tools can adopt this specification."),(0,a.kt)("p",null,"It boils down to three key sets of artifacts: ",(0,a.kt)("inlineCode",{parentName:"p"},"jobs"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"triggers"),", and\n",(0,a.kt)("inlineCode",{parentName:"p"},"credentials"),". Respectively, they determine (1) what actions must be performed,\n(2) when they must be performed, and (3) what, if any, authentication they'll\nneed to perform them."),(0,a.kt)("p",null,"If you're interested in contributing to the specification, reach out to OpenFn\nvia the ",(0,a.kt)("a",{parentName:"p",href:"https://community.openfn.org"},"community forum"),", write to us, or suggest\nchanges by submitting a pull request here."),(0,a.kt)(i.Z,{url:"https://www.youtube.com/watch?v=9xXK5xoiMgA",mdxType:"ReactPlayer"}),(0,a.kt)("h2",{id:"proposal-v2-latest"},"Proposal v2 ",(0,a.kt)("inlineCode",{parentName:"h2"},"@latest")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"jobs:\n  job-1:\n    expression: >\n      registerPatient({\n        patient-id: state.data.id,\n        dob: state.data.birth\n      })\n    adaptor: '@openfn/language-openmrs'\n    trigger: trigger-1\n    credential: my-secret-credential\n  recurring-job:\n    expression: >\n      alterState(state => {\n        console.log(\"Hi there!\")\n        return state;\n      })\n    adaptor: '@openfn/language-common'\n    trigger: every-minute\n  flow-job:\n    expression: >\n      alterState(state => {\n        state.data.number = state.data.number * 3\n        return state;\n      })\n    adaptor: '@openfn/language-common'\n    trigger: after-j1\n  catch-job:\n    expression: >\n      alterState(state => {\n        state.message = \"handled it.\"\n        return state;\n      })\n    adaptor: '@openfn/language-common'\n    trigger: j1-fails\n\ntriggers:\n  trigger-1:\n    criteria: '{\"number\":2}'\n  every-minute:\n    cron: '* * * * *'\n  after-j1:\n    success: job-1\n  j1-fails:\n    failure: job-1\n\n# Note that credential keys get copied, but values must be manually entered\n# after the export is completed.\ncredentials:\n  my-secret-credential:\n    username: '******'\n    password: '******'\n")),(0,a.kt)("h2",{id:"other-versions"},"Other Versions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"portability-versions#proposal-v3"},"Portability Proposal v3")," ",(0,a.kt)("inlineCode",{parentName:"li"},"@next")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"portability-versions#proposal-v1"},"Portability Proposal v1"))))}f.isMDXComponent=!0}}]);