"use strict";(self.webpackChunk_openfn_docs=self.webpackChunk_openfn_docs||[]).push([[3221],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),u=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=u(e.components);return i.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=u(n),p=a,m=h["".concat(s,".").concat(p)]||h[p]||d[p]||r;return n?i.createElement(m,o(o({ref:t},c),{},{components:n})):i.createElement(m,o({ref:t},c))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var u=2;u<r;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},960:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},assets:function(){return c},toc:function(){return d},default:function(){return p}});var i=n(83117),a=n(80102),r=(n(67294),n(3905)),o=["components"],l={layout:"post",title:"Improving Multistage Docker Builds using Buildx",author:"Stuart Corbishley",author_url:"https://github.com/stuartc",author_image_url:"https://avatars.githubusercontent.com/stuartc",tags:["how-to","docker","ci/cd"],featured:!0},s=void 0,u={permalink:"/fr/articles/2021/10/08/improving-multistage-docker-builds-using-buildx",editUrl:"https://github.com/openfn/docs/edit/main/articles/2021-10-08-improving-multistage-docker-builds-using-buildx.md",source:"@site/i18n/fr/docusaurus-plugin-content-blog-articles/2021-10-08-improving-multistage-docker-builds-using-buildx.md",title:"Improving Multistage Docker Builds using Buildx",description:"So you're using docker's multi-stage builds and noticed that your build times aren't nearly as quick as you expected?",date:"2021-10-08T00:00:00.000Z",formattedDate:"8 octobre 2021",tags:[{label:"how-to",permalink:"/fr/articles/tags/how-to"},{label:"docker",permalink:"/fr/articles/tags/docker"},{label:"ci/cd",permalink:"/fr/articles/tags/ci-cd"}],readingTime:5.945,truncated:!0,authors:[{name:"Stuart Corbishley",url:"https://github.com/stuartc",imageURL:"https://avatars.githubusercontent.com/stuartc"}],prevItem:{title:"Testing a React app, the blurred line between Unit, integration and E2E",permalink:"/fr/articles/2021/10/22/testing-react-app-with-jest-hound"},nextItem:{title:"Wrapping my head around jobs",permalink:"/fr/articles/2021/07/05/wrapping-my-head-around-jobs"}},c={authorsImageUrls:[void 0]},d=[{value:"Buildx",id:"buildx",children:[{value:"Local Cache",id:"local-cache",children:[],level:3},{value:"Remote Cache",id:"remote-cache",children:[],level:3}],level:2},{value:"Tips",id:"tips",children:[],level:2},{value:"Closing thoughts",id:"closing-thoughts",children:[],level:2},{value:"Resources",id:"resources",children:[],level:2}],h={toc:d};function p(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"So you're using docker's multi-stage builds and noticed that your build times aren't nearly as quick as you expected?"),(0,r.kt)("p",null,"As many teams who spend more and more time using docker, it's quite common to get into multi-stage builds; usually resulting in significantly smaller images."),(0,r.kt)("p",null,"However this comes with a pretty significant dilemma with caching. Even when using the ",(0,r.kt)("inlineCode",{parentName:"p"},"--cache-from")," flag when building, docker only caches the last image."),(0,r.kt)("p",null,"One proposed solution",(0,r.kt)("sup",null,(0,r.kt)("a",{parentName:"p",href:"#ref1"},"1")),", is to pull, build and push each individual stage. Coming with tight coupling between the shape of your Dockerfile and your build process/scripts."),(0,r.kt)("p",null,"The other solution uses Docker Buildx which the document describes as:"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Docker Buildx is a CLI plugin that extends the docker command with the full support of the features provided by Moby BuildKit builder toolkit. It provides the same user experience as docker build with many new features like creating scoped builder instances and building against multiple nodes concurrently.")),(0,r.kt)("p",null,"While that sounds pretty cool, it doesn't really touch on caching. This actually took me a while to find out that it would in fact do caching very differently. In fact it's a very different experience using it, and has lots of really cool features that further detach you from the local docker state allowing you to build in environments that are stateless - such as Google CloudBuild without having to wire up some kind of persistence or file caching scheme."),(0,r.kt)("h2",{id:"buildx"},"Buildx"),(0,r.kt)("p",null,"We're only going to scratch the surface of Buildx, and with that let's get the absolute minimum working; build our image locally."),(0,r.kt)("h3",{id:"local-cache"},"Local Cache"),(0,r.kt)("p",null,"First things first we need to create a builder, and select it for use. This is important as without creating a buildx builder (and setting it as the default), buildx will use the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker")," driver instead of the ",(0,r.kt)("inlineCode",{parentName:"p"},"docker-container")," driver which we want in order to take advantage of cache exporting."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker buildx create --name mybuilder --use\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"You only need to run this once, except in the case of CloudBuild where each invocation is a new node.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"docker buildx build \\\n  --cache-from=type=local,src=/tmp/buildx-cache \\\n  --cache-to=type=local,dest=/tmp/buildx-cache \\\n  --load \\\n  .\n")),(0,r.kt)("p",null,"While the ",(0,r.kt)("inlineCode",{parentName:"p"},"--cache-*")," options aren't specifically required when running ",(0,r.kt)("inlineCode",{parentName:"p"},"build"),", as ",(0,r.kt)("inlineCode",{parentName:"p"},"buildx")," does manage its own local cache (distinct from the regular docker cache), it's there to emphasise the options that cache can be provided via the CLI options."),(0,r.kt)("p",null,"This is about as close as you get to a regular docker build, with the significant difference being that you have to specify where to cache from and to."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"--load")," flag is to tell buildx to set the output to the local docker daemon. Without that you won't actually get a resulting image to run. However, depending on your use case, this could be seen as a convenience - if you're wanting to run your tests inside your build; a resulting image isn't particularly useful."),(0,r.kt)("h3",{id:"remote-cache"},"Remote Cache"),(0,r.kt)("p",null,"Now comes to the part I'm most interested in, caching in a stateless/remote environment. Multipart builds for us at OpenFn are essential, since we use Elixir and like other compiled languages there is a lot to be gained by only shipping the stuff you're going to run; and no language is safe from requiring several times more 'stuff' in order to build our apps."),(0,r.kt)("p",null,"Buildx supports a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/docker/buildx/blob/master/docs/reference/buildx_build.md#-export-build-cache-to-an-external-cache-destination---cache-to"},"handful of different types")," of caching sources and destinations. We're going to be using the ",(0,r.kt)("inlineCode",{parentName:"p"},"registry")," type, where you point the cache at a repository reference (repo/image:tag style)."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"One thing to note is that Google Container Registry does not support the metadata/manifest format that buildx uses, so if you're using Google Cloud you will need to start using Artifact Registry.")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Inline")),(0,r.kt)("p",null,"Push the image and the cache together:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"...\n--cache-from=type=registry,ref=$IMAGE_NAME \\\n--cache-to=type=inline \\\n...\n")),(0,r.kt)("p",null,"This comes with the constraint that cache mode is always ",(0,r.kt)("inlineCode",{parentName:"p"},"min"),", which only exports/caches the resulting layers; which is still better than the plain docker build caching but I think having the intermediary layers is generally a win. We want to avoid a single line change invalidating an entire build step."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Registry")),(0,r.kt)("p",null,"Resulting image and cache are separated:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"...\n--cache-from=type=registry,ref=$IMAGE_NAME-build-cache \\\n--cache-to=type=registry,ref=$IMAGE_NAME-build-cache,mode=max \\\n...\n")),(0,r.kt)("p",null,"Again coming back to the cache mode, here being ",(0,r.kt)("inlineCode",{parentName:"p"},"max"),"; all intermediary laters are exported to the cache image as well."),(0,r.kt)("p",null,"I have opted to create ",(0,r.kt)("em",{parentName:"p"},"two")," images, one for caching and another for the resulting image used to deploy. This gains us a much more granular cache and the ability to more easily manage the cache image - like deleting the whole thing when wanting to invalidate the cache. Not to mention I'm fairly sure the size of our images that get pulled on kubernetes would get significantly larger with many more layers."),(0,r.kt)("p",null,"It feels like a safer bet to have lean images for kubernetes to pull, and chunky cache images specifically for speeding up build."),(0,r.kt)("p",null,"Depending on your setup, pulling large images can get ",(0,r.kt)("em",{parentName:"p"},"seriously")," expensive in a reasonably active deployment environment - like on AWS ECS without using PrivateLink."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"It appears the ",(0,r.kt)("inlineCode",{parentName:"p"},"moby/buildkit")," documentation also demonstrates ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/moby/buildkit#registry-push-image-and-cache-separately"},"this")," approach.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"IMAGE_NAME=us-east4-docker.pkg.dev/<project-name>/platform/app \\\ndocker buildx build \\\n  -t $IMAGE_NAME:latest \\\n  --cache-from=type=registry,ref=$IMAGE_NAME-build-cache \\\n  --cache-to=type=registry,ref=$IMAGE_NAME-build-cache,mode=max \\\n  --push \\\n  --progress=plain \\\n  .\n")),(0,r.kt)("p",null,"This implies that the cache image is named with the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},"-build-cache"),":",(0,r.kt)("br",{parentName:"p"}),"\n",(0,r.kt)("inlineCode",{parentName:"p"},"us-east4-docker.pkg.dev/<project-name>/platform/app[-build-cache]"),"."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"--push")," argument tells buildx to push the resulting image to the registry."),(0,r.kt)("h2",{id:"tips"},"Tips"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Clearing the local cache")),(0,r.kt)("p",null,"As mentioned before, buildx has its own cache and in order to clear the cache while debugging and readying a Dockerfile for remote building you'll probably need to reach for ",(0,r.kt)("inlineCode",{parentName:"p"},"docker buildx prune"),"."),(0,r.kt)("h2",{id:"closing-thoughts"},"Closing thoughts"),(0,r.kt)("p",null,"Using buildx has been a really pleasant experience, having personally attempted using it a few times over the last 3 years; the most recent one being the first time I felt confident getting it into production. As with any sufficiently flexible build tooling, the errors and issues you can run into range from complete gibberish, genuinely concerning inconsistencies to architectural choices that you haven't fully caught up on; requiring an ever growing list of changes you need to make to your own build process."),(0,r.kt)("p",null,"Our initial observations have been great, reasonable changes on our build have gone from 28 minutes to around 9 minutes."),(0,r.kt)("p",null,"While I have encountered a few confusing cache invalidations, especially when building locally, exporting the cache to a repository and then having CloudBuild use the image cache. And occasionally locally having what feels like ",(0,r.kt)("em",{parentName:"p"},"really")," aggressive caching on intermediate steps, leading me to pruning the local cache."),(0,r.kt)("p",null,"But overall, these issues aren't necessarily buildx issues and more likely a combination of building docker images in general except with many more steps accounted for by the cache."),(0,r.kt)("p",null,"It's kinda hard to see now what the exact issues I had with it in the past, but hey!"),(0,r.kt)("p",null,"Buildx has given me what I 'expected' with docker multi-stage builds, and having the cache in a repository completely side-steps having to attach a shared volume or copying from a storage bucket."),(0,r.kt)("h2",{id:"resources"},"Resources"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://pythonspeed.com/articles/faster-multi-stage-builds/"},"Multi-stage builds #3: Speeding up your builds")," ",(0,r.kt)("a",{name:"ref1"},(0,r.kt)("sup",null,"1"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.docker.com/buildx/working-with-buildx/"},"Docker Buildx")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/docker/buildx/blob/master/docs/reference/buildx_build.md#buildx-build"},"buildx build reference")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/moby/buildkit#registry-push-image-and-cache-separately"},"mody/buildkey Registry cache exporter"))))}p.isMDXComponent=!0}}]);